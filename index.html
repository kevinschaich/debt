<!DOCTYPE html>
<html>
<head>
    <title>3300 - P1</title>
    <style>
        #xaxis .domain {
            fill:none;
        }
        body {
            font-family: Roboto;
        }
        .x.axis {
            font-size: 8pt;
            fill: #323232;
            border: 1px solid #323232;
        }
        .axis path {
            fill: none;
        }
    </style>
    <script>
            // First, checks if it isn't implemented yet.
            if (!String.prototype.format) {
              String.prototype.format = function() {
                var args = arguments;
                return this.replace(/{(\d+)}/g, function(match, number) {
                  return typeof args[number] != 'undefined'
                  ? args[number]
                  : match
                  ;
              });
            };
        }
    </script>

</head>
<body>
    <div id="wrapper">
    </div>
    <div id="padding">
    </div>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>
        d3.csv("data2.csv", function(data) {

            var BarHeight = 40;
            var BarSpacing = 20;
            var paddingLeft = 250;
            var paddingRight = paddingLeft;
            var paddingTop = BarSpacing;
            var paddingBottom = BarSpacing;
            var scales = [1000, 1000000, 1000000000, 1000000000000,  20000000000000];
            var colors = ['hsl(0, 100%, 70%)', 'hsl(15, 100%, 70%)', 'hsl(30, 100%, 70%)', 'hsl(45, 100%, 70%)', 'hsl(60, 100%, 70%)', 'hsl(75, 100%, 70%)', 'hsl(90, 100%, 70%)', 'hsl(105, 100%, 70%)', 'hsl(120, 100%, 70%)', 'hsl(135, 100%, 70%)', 'hsl(150, 100%, 70%)', 'hsl(165, 100%, 70%)', 'hsl(180, 100%, 70%)', 'hsl(195, 100%, 70%)', 'hsl(210, 100%, 70%)', 'hsl(225, 100%, 70%)', 'hsl(240, 100%, 70%)', 'hsl(255, 100%, 70%)', 'hsl(270, 100%, 70%)', 'hsl(285, 100%, 70%)', 'hsl(300, 100%, 70%)', 'hsl(315, 100%, 70%)', 'hsl(330, 100%, 70%)', 'hsl(345, 100%, 70%)', 'hsl(359, 100%, 70%)', 'hsl(0, 100%, 70%)'];

            var titleOffset = 0;
            var subtitleOffset = 10;

            var categories = [];
            for (var i = 0; i < data.length; i++) {
                if (categories.indexOf(data[i]['category']) === -1)
                    categories.push(data[i]['category']);
            }
            console.log(categories.length);
            console.log(colors.length);

            var graphSpacing = BarHeight * 2;

            var width = window.innerWidth;
            var height = data.length * (BarHeight + BarSpacing) + (graphSpacing * scales.length);
            var canvas = d3.select('#wrapper')
            .append('svg')
            .attr("id","main")
            .attr({'width': width,'height': height});

            var cur_height = 0;

            function drawGraph(data, xmax) {
                var height = data.length * (BarHeight + BarSpacing);
                var canvas = d3.select('#wrapper')
                .select('#main')
                .append("g")
                .attr("transform", "translate(0," + cur_height + ")");

                var tickVals = [0];

                for (var i = 0; i <= 10; i++) {
                    tickVals.push((xmax / 10) * i);
                }

                var xmin = 0;

                var xscale = d3.scale.linear()
                .domain([xmin, xmax])
                .range([0, width - (paddingLeft + paddingRight)]);

                var yscale = d3.scale.linear()
                .domain([0,data.length - 1])
                .range([height - paddingBottom, paddingTop]);

                var colorScale = d3.scale.quantize()
                .domain([0,data.length - 1])
                .range(colors);

                var formatValue = d3.format("$s");

                var xAxis = d3.svg.axis();
                xAxis
                .orient('bottom')
                .scale(xscale)
                .tickValues(tickVals)
                .tickFormat(function(d) {
                    if (width > 1600) {
                        return formatValue(d)
                        .replace('k', ' thousand')
                        .replace('M', ' million')
                        .replace('G', ' billion')
                        .replace('T', ' trillion');
                    }
                    else {
                        return formatValue(d)
                        .replace('k', ' k')
                        .replace('M', ' M')
                        .replace('G', ' B')
                        .replace('T', ' T');
                    }
                });

                var yAxis = d3.svg.axis();
                yAxis
                .orient('left')
                .scale(yscale)
                .tickFormat(function(d,i){
                    return data[i].name;
                })
                .tickValues(d3.range(data.length));

                var subyAxis = d3.svg.axis();
                subyAxis
                .orient('left')
                .scale(yscale)
                .tickFormat(function(d,i){
                    try {
                        return data[i].Subtitle;
                    } catch(e) {}
                });

                canvas.append("g")
                .attr("transform", "translate(" + paddingLeft +"," + (height - paddingBottom + BarHeight) + ")")
                .attr("class", "x axis").call(xAxis);

                canvas.append("g")
                .attr("transform", "translate(" + (paddingLeft - 10) + ","+titleOffset+")")
                .attr("class", "y axis").call(yAxis);

                canvas.append("g")
                .attr("transform", "translate(" + (paddingLeft - 10) + ","+subtitleOffset+")")
                .attr("class", "y axis").call(subyAxis);

                var chart = canvas
                .selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .datum(function (d){
                    d["height_offset"] = cur_height;
                    return d; })
                .attr('id','bars')
                .attr('height', BarHeight)
                .attr({
                    'x': paddingLeft,
                    'width': function(d) {
                        return xscale(parseFloat(d.price));
                    },
                    'y': function(d,i) {
                        return yscale(i) - (BarHeight / 2);
                    }
                })
                .style({
                    'fill': function(d, i) {
                        var i = categories.indexOf(data[i]['category']) * 3;
                        return colors[i];
                    }
                });

                tickVals.forEach(function(x) {
                    canvas.append('rect')
                    .attr({
                        'x': xscale(parseFloat(x)) + paddingLeft,
                        'width': 5,
                        'y': 0,
                        'height': height
                    })
                    .style('fill', 'white')
                });

                cur_height += height + graphSpacing;
            }

            var cur = 0;
            var i = 0;
            var partitions = new Array();
            partitions.push(new Array());
            data.forEach(function(point) {
                if (point.price <= scales[cur]) {
                    partitions[i].push(point);
                }
                else {
                    drawGraph(partitions[i].reverse(),scales[cur]);
                    i++;
                    partitions.push(new Array());
                    partitions[i].push(point);
                    cur++;
                }
            });
            drawGraph(partitions[i].reverse(),scales[cur]);

            var linkingGroups = {};

            var bars = d3.selectAll('#bars');
            bars.each(function(i) {
                if (i['Linking']){
                    var offset_h = parseFloat(i["height_offset"]);
                    var y = parseFloat(d3.select(this).attr("y"));
                    if (linkingGroups[i['Linking']]){
                        linkingGroups[i['Linking']].unshift(offset_h+y);
                    }
                    else{
                        linkingGroups[i['Linking']] = [offset_h+y];
                    }
                }
            });

            var curveMax = 800;

        // draw a curve path for each linking
        Object.keys(linkingGroups).forEach(function (d,i){
            pathinfo = [];
            linkingGroups[d].forEach(function (val,i){
                pathinfo.push(val);
            });

            var baryMidpoint = BarHeight/2;

            var xCurveScaling = d3.scale.linear()
            .domain([0, curveMax])
            .range([paddingLeft, width - paddingRight]);

            var widthScaling = d3.scale.linear()
            .domain([0, curveMax])
            .range([8,30]);

            for (var i=0;i<pathinfo.length-1;i++){
                var y1 = pathinfo[i]+baryMidpoint;
                var y2 = pathinfo[i+1]+baryMidpoint;
                var midy = (y1+y2)/2;
                var scalingFactor = midy - Math.min(y1,y2);
                var midx = xCurveScaling(scalingFactor);
                var path = "M 255 {0} C {2} {0} {2} {1} 255 {1}".format(y1,y2,midx);

                canvas.append("svg:path")
                .attr("d",path)
                .style("stroke-width", widthScaling(scalingFactor))
                .style("stroke", "grey")
                .style("fill", "none")
                .style("opacity","0.5");
            };
        });
    });
</script>
</body>
</html>
