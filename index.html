<!DOCTYPE html>
<html>
<head>
    <title>3300 - P1</title>
    <style>
        svg {
            margin-top: 0px;
            margin-left: 0px;
            margin-right: 0px;
            /*border: 1px solid rgba(0, 0, 0, .2);*/
        }
        #xaxis .domain {
            fill:none;
            stroke:#000;
        }
        #xaxis text, #yaxis text {
            font-size: 12px;
        }
        body {
            font-family: Roboto;
        }
        #padding {
            /*margin-bottom: 5000px;*/
        }
        .axis path {
            fill: none;
            stroke: #323232;
        }
        .axis line {
            stroke: #323232;
        }
        .axis text {
            fill: #323232;
        }
    </style>
    <script>
            // First, checks if it isn't implemented yet.
        if (!String.prototype.format) {
          String.prototype.format = function() {
            var args = arguments;
            return this.replace(/{(\d+)}/g, function(match, number) { 
              return typeof args[number] != 'undefined'
                ? args[number]
                : match
              ;
            });
          };
        }
    </script>

</head>
<body>
    <div id="wrapper">
    </div>
    <div id="padding">
    </div>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>
        d3.csv("data2.csv", function(data) {

            var BarHeight = 20;
            var paddingLeft = 250;
            var paddingRight = 250;
            var paddingTop = 10;
            var paddingBottom = 50;
            var width = window.innerWidth;
            var height = data.length * 30;
            var canvas = d3.select('#wrapper')
            .append('svg')
            .attr("id","main")
            .attr({'width': width,'height': height});

            var cur_height = 0;

            function drawGraph(data, xmax) {
                var width = window.innerWidth;
                var height = data.length * 30;
                var canvas = d3.select('#wrapper')
                .select('#main')
                .append("g")
                .attr("transform", "translate(0," + cur_height + ")");

                var paddingLeft = 250;
                var paddingRight = 250;
                var paddingTop = 10;
                var paddingBottom = 50;
                var colors = ['#FFB44C', '#FF9300', '#CC7600'];
                var tickVals = [0, xmax];
                var xmin = 0;
                var xscale = d3.scale.linear()
                .domain([xmin, xmax])
                .range([0, width - (paddingLeft + paddingRight)]);
                var yscale = d3.scale.linear()
                .domain([0,data.length - 1])
                .range([height - paddingBottom, paddingTop]);
                var colorScale = d3.scale.quantize()
                .domain([0,data.length - 1])
                .range(colors);
                var xAxis = d3.svg.axis();
                xAxis
                .orient('bottom')
                .scale(xscale).tickValues(tickVals);
                var yAxis = d3.svg.axis();
                yAxis
                .orient('left')
                .scale(yscale)
                .tickFormat(function(d,i){
                    return data[i].name;
                })
                .tickValues(d3.range(data.length));
                canvas.append("g")
                .attr("transform", "translate(" + paddingLeft +"," + (height - paddingBottom + 20) + ")")
                .attr("class", "x axis").call(xAxis);
                canvas.append("g")
                .attr("transform", "translate(" + (paddingLeft - 10) + ",0)")
                .attr("class", "y axis").call(yAxis);
                d3.selectAll(".y line, .y path, .y text").style("stroke","none").attr("font-size", "11px").attr("font-family", "Calibri");
                d3.selectAll(".x text").attr("font-size", "11px").attr("font-family", "Calibri")
                var chart = canvas
                .selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .datum(function (d){
                    d["height_offset"] = cur_height;
                    return d; })
                .attr('id','bars')
                .attr('height', BarHeight)
                .attr({
                    'x': paddingLeft,
                    'width': function(d) {
                        //console.log(parseFloat(d.price));
                        //console.log("Scaled:" + xscale(parseFloat(d.price)));
                        return xscale(parseFloat(d.price));
                    },
                    'y': function(d,i) {
                        return yscale(i) - 10;
                    }
                })
                .style({
                    'fill': function() {
                        var i = Math.floor(Math.random() * colors.length);
                        return colors[i];
                    }
                });
                cur_height+=height;
            }

            var scales = [1000,1000000, 1000000000000,  19000000000000]
            var cur = 0;
            var i = 0;
            var partitions = new Array();
            partitions.push(new Array());
            data.forEach(function(point) {
                // console.log(scales[cur]);
                if (point.price <= scales[cur]) {
                    partitions[i].push(point);
                    // console.log(partitions[i]);
                }
                else {
                    drawGraph(partitions[i].reverse(),scales[cur]);
                    i++;
                    partitions.push(new Array());
                    partitions[i].push(point);
                    cur++;
                }
            });
            drawGraph(partitions[i].reverse(),scales[cur]);
            // console.log(partitions);

        var linkingGroups = {};

        var bars = d3.selectAll('#bars');
        bars.each(function(i) {
            if (i['Linking']){
                var offset_h = parseFloat(i["height_offset"]);
                var y = parseFloat(d3.select(this).attr("y"));
                if (linkingGroups[i['Linking']]){
                    linkingGroups[i['Linking']].unshift(offset_h+y);
                }
                else{
                    linkingGroups[i['Linking']] = [offset_h+y];
                }
            }
        });

        // draw a curve path for each linking
        Object.keys(linkingGroups).forEach(function (d,i){
            pathinfo = [];
            linkingGroups[d].forEach(function (val,i){
                console.log(val);
                pathinfo.push(val);
            });

            var baryMidpoint = BarHeight/2;

            xCurveScaling = d3.scale.linear()
                .domain([0,400])
                .range([paddingLeft, width - paddingRight]);

            for (var i=0;i<pathinfo.length-1;i++){
                var y1 = pathinfo[i]+baryMidpoint;
                var y2 = pathinfo[i+1]+baryMidpoint;
                var midy = (y1+y2)/2;
                var midx = xCurveScaling(midy - y1);
                // var path = "M 250 {0} Q {2} {3} 250 {1}".format(y1,y2,midx,midy);
                var path = "M 250 {0} C {2} {0} {2} {1} 250 {1}".format(y1,y2,midx);

                canvas.append("svg:path")
                .attr("d",path)
                .style("stroke-width", 10)
                .style("stroke", "grey")
                .style("fill", "none")  
                .style("opacity","0.5");            
            };
        });
    });
    </script>
</body>
</html>
