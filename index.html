<!DOCTYPE html>
<html>
<head>
    <title>3300 - P1</title>
    <style>
        svg {
            margin-top: 0px;
            margin-left: 0px;
            margin-right: 0px;
            /*border: 1px solid rgba(0, 0, 0, .2);*/
        }
        #xaxis .domain {
            fill:none;
            stroke:#000;
        }
        #xaxis text, #yaxis text {
            font-size: 14px;
        }
        body {
            font-family: Roboto;
        }
        #padding {
            /*margin-bottom: 5000px;*/
        }
        .axis path {
            fill: none;
            stroke: #323232;
        }
        .axis line {
            stroke: #323232;
        }
        .axis text {
            fill: #323232;
        }
    </style>
    <script>
            // First, checks if it isn't implemented yet.
            if (!String.prototype.format) {
              String.prototype.format = function() {
                var args = arguments;
                return this.replace(/{(\d+)}/g, function(match, number) {
                  return typeof args[number] != 'undefined'
                  ? args[number]
                  : match
                  ;
              });
            };
        }
    </script>

</head>
<body>
    <div id="wrapper">
    </div>
    <div id="padding">
    </div>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>
        d3.csv("data2.csv", function(data) {

            var BarHeight = 40;
            var BarSpacing = 20;
            var paddingLeft = 250;
            var paddingRight = paddingLeft;
            var paddingTop = BarSpacing;
            var paddingBottom = BarSpacing;
            var scales = [1000, 1000000, 1000000000, 1000000000000,  20000000000000];
            var scaleNames = ['thousand', 'million', 'billion', 'trillion',  'trillion'];

            var graphSpacing = BarHeight * 2;

            var width = window.innerWidth;
            var height = data.length * (BarHeight + BarSpacing) + (graphSpacing * scales.length);
            var canvas = d3.select('#wrapper')
            .append('svg')
            .attr("id","main")
            .attr({'width': width,'height': height});

            var cur_height = 0;

            function drawGraph(data, xmax) {
                var height = data.length * (BarHeight + BarSpacing);
                var canvas = d3.select('#wrapper')
                .select('#main')
                .append("g")
                .attr("transform", "translate(0," + cur_height + ")");

                var colors = ['#FFB44C', '#FF9300', '#CC7600'];
                var tickVals = [0, xmax];
                var xmin = 0;
                var xscale = d3.scale.linear()
                .domain([xmin, xmax])
                .range([0, width - (paddingLeft + paddingRight)]);
                var yscale = d3.scale.linear()
                .domain([0,data.length - 1])
                .range([height - paddingBottom, paddingTop]);
                var colorScale = d3.scale.quantize()
                .domain([0,data.length - 1])
                .range(colors);
                var xAxis = d3.svg.axis();
                xAxis
                .orient('bottom')
                .scale(xscale).tickValues(tickVals);
                var yAxis = d3.svg.axis();
                yAxis
                .orient('left')
                .scale(yscale)
                .tickFormat(function(d,i){
                    return data[i].name;
                })
                .tickValues(d3.range(data.length));
                canvas.append("g")
                .attr("transform", "translate(" + paddingLeft +"," + (height - paddingBottom + BarHeight) + ")")
                .attr("class", "x axis").call(xAxis);
                canvas.append("g")
                .attr("transform", "translate(" + (paddingLeft - 10) + ",0)")
                .attr("class", "y axis").call(yAxis);
                d3.selectAll(".y line, .y path, .y text").style("stroke","none").attr("font-size", "11px").attr("font-family", "Calibri");
                d3.selectAll(".x text").attr("font-size", "11px").attr("font-family", "Calibri")
                var chart = canvas
                .selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .datum(function (d){
                    d["height_offset"] = cur_height;
                    return d; })
                .attr('id','bars')
                .attr('height', BarHeight)
                .attr({
                    'x': paddingLeft,
                    'width': function(d) {
                        //console.log(parseFloat(d.price));
                        //console.log("Scaled:" + xscale(parseFloat(d.price)));
                        return xscale(parseFloat(d.price));
                    },
                    'y': function(d,i) {
                        return yscale(i) - (BarHeight / 2);
                    }
                })
                .style({
                    'fill': function() {
                        var i = Math.floor(Math.random() * colors.length);
                        return colors[i];
                    }
                });
                cur_height += height + graphSpacing;
            }

            var cur = 0;
            var i = 0;
            var partitions = new Array();
            partitions.push(new Array());
            data.forEach(function(point) {
                if (point.price <= scales[cur]) {
                    partitions[i].push(point);
                }
                else {
                    drawGraph(partitions[i].reverse(),scales[cur]);
                    i++;
                    partitions.push(new Array());
                    partitions[i].push(point);
                    cur++;
                }
            });
            drawGraph(partitions[i].reverse(),scales[cur]);

            var linkingGroups = {};

            var bars = d3.selectAll('#bars');
            bars.each(function(i) {
                if (i['Linking']){
                    var offset_h = parseFloat(i["height_offset"]);
                    var y = parseFloat(d3.select(this).attr("y"));
                    if (linkingGroups[i['Linking']]){
                        linkingGroups[i['Linking']].unshift(offset_h+y);
                    }
                    else{
                        linkingGroups[i['Linking']] = [offset_h+y];
                    }
                }
            });

            var curveMax = 800;

        // draw a curve path for each linking
        Object.keys(linkingGroups).forEach(function (d,i){
            pathinfo = [];
            linkingGroups[d].forEach(function (val,i){
                pathinfo.push(val);
            });

            var baryMidpoint = BarHeight/2;

            var xCurveScaling = d3.scale.linear()
            .domain([0, curveMax])
            .range([paddingLeft, width - paddingRight]);

            var widthScaling = d3.scale.linear()
            .domain([0, curveMax])
            .range([8,30]);

            for (var i=0;i<pathinfo.length-1;i++){
                var y1 = pathinfo[i]+baryMidpoint;
                var y2 = pathinfo[i+1]+baryMidpoint;
                var midy = (y1+y2)/2;
                var scalingFactor = midy - Math.min(y1,y2);
                var midx = xCurveScaling(scalingFactor);
                var path = "M 250 {0} C {2} {0} {2} {1} 250 {1}".format(y1,y2,midx);

                canvas.append("svg:path")
                .attr("d",path)
                .style("stroke-width", widthScaling(scalingFactor))
                .style("stroke", "grey")
                .style("fill", "none")
                .style("opacity","0.5");
            };
        });
    });
</script>
</body>
</html>
