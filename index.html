<!DOCTYPE html>
<html>
<head>
    <title>3300 - P1</title>
    <style>
        svg {
            margin-top: 0px;
            margin-left: 0px;
            margin-right: 0px;
            /*border: 1px solid rgba(0, 0, 0, .2);*/
        }
        #xaxis .domain {
            fill:none;
            stroke:#000;
        }
        #xaxis text, #yaxis text {
            font-size: 12px;
        }
        body {
            font-family: Roboto;
        }
        #padding {
            /*margin-bottom: 5000px;*/
        }
        .axis path {
            fill: none;
            stroke: #323232;
        }
        .axis line {
            stroke: #323232;
        }
        .axis text {
            fill: #323232;
        }
    </style>
</head>
<body>
    <div id="wrapper">
    </div>
    <div id="padding">
    </div>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script>

        d3.csv("data.csv", function(data) {
            // console.log(data);

            function drawGraph(data, xmax) {

                var width = window.innerWidth;
                var height = data.length * 30;

                var canvas = d3.select('#wrapper')
                .append('svg')
                .attr({'width': width,'height': height});

                var paddingLeft = 500;
                var paddingRight = 100;
                var paddingTop = 10;
                var paddingBottom = 50;

                var colors = ['#0000b4','#0082ca','#0094ff','#0d4bcf','#0066AE','#074285','#00187B','#285964','#405F83','#416545','#4D7069','#6E9985','#7EBC89','#0283AF','#79BCBF','#99C19E'];

                var tickVals = [0, xmax];

                var xmin = 0;

                var xscale = d3.scale.linear()
                .domain([xmin, xmax])
                .range([0, width - (paddingLeft + paddingRight)]);

                var yscale = d3.scale.linear()
                .domain([0,data.length - 1])
                .range([height - paddingBottom, paddingTop]);

                var colorScale = d3.scale.quantize()
                .domain([0,data.length - 1])
                .range(colors);

                var xAxis = d3.svg.axis();
                xAxis
                .orient('bottom')
                .scale(xscale).tickValues(tickVals);

                var yAxis = d3.svg.axis();
                yAxis
                .orient('left')
                .scale(yscale)
                .tickFormat(function(d,i){
                    return data[i].name;
                })
                .tickValues(d3.range(data.length));

                canvas.append("g")
                .attr("transform", "translate(" + paddingLeft +"," + (height - paddingBottom + 20) + ")")
                .attr("class", "x axis").call(xAxis);

                canvas.append("g")
                .attr("transform", "translate(" + (paddingLeft - 10) + ",0)")
                .attr("class", "axis").call(yAxis);

                var chart = canvas
                .selectAll('rect')
                .data(data)
                .enter()
                .append('rect')
                .attr('id','bars')
                .attr('height', 20)
                .attr({
                    'x': paddingLeft,
                    'width': function(d) {
                        console.log(parseFloat(d.price));
                        console.log("Scaled:" + xscale(parseFloat(d.price)));
                        return xscale(parseFloat(d.price));
                    },
                    'y': function(d,i) {
                        return yscale(i) - 10;
                    }
                })
                .style('fill','black');



            }

            var scales = [1000, 100000, 100000000, 100000000000,  19000000000000]
            var cur = 0;
            var i = 0;
            var partitions = new Array();

            partitions.push(new Array());

            data.forEach(function(point) {
                console.log(scales[cur]);
                if (point.price <= scales[cur]) {
                    partitions[i].push(point);
                    console.log(partitions[i]);
                }
                else {
                    drawGraph(partitions[i].reverse(),scales[cur]);
                    i++;
                    partitions.push(new Array());
                    partitions[i].push(point);
                    cur++;
                }
            });
            drawGraph(partitions[i].reverse(),scales[cur]);

            console.log(partitions);
        });

    </script>
</body>
</html>